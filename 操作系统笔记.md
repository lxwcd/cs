操作系统学习笔记

# 学习资源
> [深入理解计算机系统 第三版](https://pan.baidu.com/s/1j6u_txqDCMLX-jCdnRdbOw?pwd=oqon)
> [现代操作系统 第四版](https://pan.baidu.com/s/1JSv_M4K9R3nmTVdGOqSAtQ?pwd=jsnx)
> [图解系统](https://xiaolincoding.com/os/)

# 线路位宽和 CPU 位宽
> [线路位宽与 CPU 位宽](https://xiaolincoding.com/os/1_hardware/how_cpu_run.html#线路位宽与-cpu-位宽)

1. 线路位宽（Bus Width）
线路位宽是指计算机系统中数据传输通道的宽度，即一次可以传输的数据位数。
它通常用于描述内部数据传输的带宽和数据通路的宽度。
例如，系统的数据总线和地址总线的宽度可以被称为线路位宽。
线路位宽的大小影响着系统的数据传输速度和处理能力。

2. CPU位宽（CPU Word Size）
CPU位宽是指CPU寄存器中一次可以处理的数据位数。
它表示CPU内部的数据处理能力和寄存器的大小。
常见的CPU位宽有8位、16位、32位和64位等。
较大的CPU位宽通常意味着CPU能够一次处理更多的数据，提供更高的计算性能和数据吞吐量。

虽然线路位宽和CPU位宽都与计算机系统中的数据处理和传输有关，但它们描述的是不同的方面。
线路位宽主要关注数据传输通道的宽度和带宽，而CPU位宽则表示CPU的内部数据处理能力。
它们在系统设计和性能评估中都扮演着重要的角色。

当我们考虑一个计算机系统的线路位宽和CPU位宽时，我们可以通过以下示例来说明它们的区别：
假设我们有一台计算机系统，其中的数据总线和地址总线的线路位宽为32位，而CPU的位宽为64位。

对于线路位宽（32位）：
- 这意味着系统的数据总线和地址总线每次可以传输32位的数据。
- 内存访问时，每个内存地址的数据在一次传输中最多可以传输32位的数据，即 4G 大小的数据。
- 当CPU要从内存中读取数据时，它可以一次性读取32位的数据，而不需要多次传输。

对于CPU位宽（64位）：
- 这意味着CPU的寄存器和数据通路可以同时处理64位的数据。
- CPU内部的算术逻辑单元（ALU）可以一次性执行64位的算术和逻辑操作。
- 当CPU从内存中读取数据时，它可以一次性读取64位的数据到寄存器中，从而进行更高精度的计算。

综上所述：
- 线路位宽（32位）描述了数据总线和地址总线的传输能力，即每次可以传输的数据位数。
- CPU位宽（64位）描述了CPU内部的寄存器和数据通路的能力，即一次可以处理的数据位数。
- CPU位宽最好不小于线路位宽

# 阻塞 非阻塞 同步 异步
> UNIX 网络编程 卷1 第三版 第六章
> 和书中讲的一样：[阻塞与非阻塞 I/O VS 同步与异步 I/O](https://www.xiaolincoding.com/os/6_file_system/file_system.html#阻塞与非阻塞-i-o-vs-同步与异步-i-o)
> 包含书中的示意图：[I / O MULTIPLEXING : THE Select AND Poll FUNCTIONS](https://www.brainkart.com/article/I-O-Multiplexing---the-Select-and-Poll-Functions_9113/)


书中五种 I/O 模型：

1. Blocking I/O model
用户程序执行系统调用后一直等待内核返回结果，此时进程处于阻塞状态
内核经过两个过程：准备数据和将数据从内核空间拷贝到用户空间

2. Nonblocking I/O model
用户程序执行系统调用，如果此时内核还未准备好数据，则返回，然后用户程序一直轮询执行系统调用，直到内核将数据准备好
在内核准备数据的过程种，用户程序没有阻塞
在内核将数据从内核空间拷贝到用户空间时，用户程序处于阻塞状态，等待返回结果

5. Asynchronous I/O model
用户执行系统调用后立即返回，然后用户程序继续执行其他操作，内核异步的准备数据然后拷贝数据，拷贝完成后发送一个信号通知用户程序
该过程全程未阻塞进行


同步（synchronous）和异步（asynchronous）：
模型 1 和 2 都是同步操作，因为用户程序都要等待结果返回才能继续执行
A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.

模型 5 是异步操作，用户程序不用等待结果，不会阻塞
An asynchronous I/O operation does not cause the requesting process to be blocked.

实际应用举例：
redis 中 save 命令是同步保存 rdb 文件，会阻塞直到文件创建完成
redis 中 bgsave 命令则是异步保存 rdb 文件，主进程会 fork 一个子进程来保存文件，主进程不等待而是立即返回后执行其他命令

