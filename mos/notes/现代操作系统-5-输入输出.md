
现代操作系统 第五章 输入/输出

# I/O 设备
I/O devices cover a huge range in speeds, which puts considerable pressure on the software to perform well over many orders of magnitude in data rates.

![](img/2023-10-09-16-53-25.png)


## I/O 设备文件类型
I/O 设备大致可以分为两类
Both block and character devices provide an interface between the user space applications and the underlying hardware or kernel services. 
They allow programs to read from and write to the devices in a standardized way, abstracting away the complexities of the underlying hardware implementation.

### 块设备
- Block devices represent devices that allow access to data in fixed-sized blocks, typically used for storage devices like hard disks, SSDs, and USB drives.
- They are accessed in terms of block I/O operations and seem to be a continuous stream of data.
- Block devices are capable of random access, meaning you can read/write data at any position within a block without the need to read the entire block.
- Examples of block devices include `/dev/sda` (hard disk), `/dev/sdb` (USB drive), and `/dev/nvme0n1` (NVMe storage device).
- Block device files have a type identifier "b" in the permissions section of the `ls -l` command output.

### 字符设备
- Character devices represent devices that can be accessed as a stream of characters, indicating a sequential flow of data.
- They typically handle devices that require input or output of data character by character, such as serial ports, terminals, or devices that deal with keyboard/mouse input.
- Character devices are accessed through byte-by-byte I/O operations.
- They generally don't support random access and operate with a stream of characters.
- Examples of character devices include `/dev/tty` (terminal), `/dev/null` (null device), and `/dev/urandom` (random number generator).
- Character device files have a type identifier "c" in the permissions section of the `ls -l` command output.
- Printers, network interfaces, mice (for pointing), rats (for psychology lab experiments), and most other devices
that are not disk-like can be seen as character devices.

## Device Controller
I/O units often consist of a mechanical component and an electronic component. 

It is possible to separate the two portions to provide a more modular and general design. 

The electronic component is called the device controller or adapter. 
On personal computers, it often takes the form of a chip on the parentboard or a printed circuit card that can be inserted into a (PCIe) expansion slot.

The mechanical component is the device itself. 

## Memory-Mapped I/O
Each controller has a few **registers** that are used for communicating with the CPU. 

By **writing** into these registers, the operating system can command the device to deliver data, accept data, switch itself on or off, or otherwise perform some action. 

By **reading** from these registers, the operating system can learn what the device’s state is, whether it is prepared to accept a new command, and so on.

In addition to the control registers, many devices have a **data buffer** that the operating system can read and write. 

For example, a common way for computers to display pixels on the screen is to have a video RAM, which is basically just a data buffer, available for programs or the operating system to write into.


The issue thus arises of how the CPU communicates with the control registers and also with the device data buffers. 
1. each control register is assigned an I/O port number, an 8- or 16-bit integer 
早期使用

2. map all the control registers into the memory space
Each control register is assigned a unique memory address to which no memory is assigned. 
This system is called memory-mapped I/O. 
In most systems, the assigned addresses are at or near the top of the address space. 

3. hybird scheme
with memory-mapped I/O data buffers and separate I/O ports for the control registers

****************

The trend in modern personal computers is to have a dedicated high-speed memory bus 

The bus is tailored to optimize memory performance, with no compromises for the sake of slow I/O devices. 
x86 systems can have multiple buses (memory, PCIe, SCSI, and USB).

![](img/2023-10-09-17-26-34.png)

The trouble with having a separate memory bus on memory-mapped machines is that the I/O devices have no way of seeing memory addresses as they go by on the memory bus, so they have no way of responding to them. 

1. One possibility is to first send all memory references to the memory. If the memory fails to respond, then the CPU tries the other buses.

2. A second possible design is to put a snooping device on the memory bus to pass all addresses presented to potentially interested I/O devices.

3. A third possible design is to filter addresses in the memory controller.
In that case, the memory controller chip contains range registers that are preloaded at boot time.
The disadvantage of this scheme is the need for figuring out at boot time which memory addresses are not really memory addresses.

## Direct Memory Access
No matter whether a CPU does or does not have memory-mapped I/O, it needs to address the device controllers to exchange data with them.

The operating system can use only DMA if the hardware has a DMA controller, which most systems do.

DMA，即直接内存访问（Direct Memory Access）是一种计算机系统中用于高效地传输数据的技术。
通常情况下，当计算机的 CPU 需要从内存中读取或写入数据时，它通过总线进行传输。
在传统的 CPU 控制下，数据的传输需要经过 CPU 的介入，这会占用 CPU 的时间和资源。

DMA 技术的引入可以绕过 CPU，直接在主存和外设之间进行数据传输，从而提高数据传输的效率。
DMA 控制器是 DMA 技术的关键组成部分，它是一个独立的硬件设备，具有自己的寄存器和逻辑电路。
DMA 控制器能够在不占用 CPU 的情况下执行数据传输操作。

使用 DMA 技术进行数据传输的过程如下：

1. CPU 配置 DMA 控制器：CPU 首先将 DMA 控制器配置为执行特定的数据传输操作。这包括指定数据传输的起始地址、目标地址、传输的数据量和传输方向等参数。

2. DMA 控制器请求总线控制权：DMA 控制器向系统总线控制器发送请求，请求获取对系统总线的控制权。

3. CPU 授予总线控制权：如果系统总线空闲，CPU 将授予 DMA 控制器对总线的控制权。

4. DMA 控制器执行数据传输：一旦获得总线控制权，DMA 控制器将直接从起始地址读取数据并将其传输到目标地址，或者从目标地址读取数据并将其传输到起始地址。

5. 数据传输完成：当数据传输完成后，DMA 控制器将释放总线控制权，并通过中断或其他机制通知 CPU。

DMA 技术的应用广泛，特别适用于需要大量数据传输的任务，例如磁盘操作、网络数据传输和音频/视频处理等。
通过使用 DMA 技术，可以减少 CPU 的负载，提高系统的响应速度和吞吐量。

![](img/2023-10-09-17-39-56.png)


***********

许多总线有两种传输模式：word-at-a-time mode 和 block mode，有些 DMA 控制器也有这两种模式中的一种
1. 逐字模式
DMA 控制器以 word 为单位传输数据
The mechanism is called cycle stealing because the device controller sneaks in and steals an occasional bus cycle from the CPU once in a while, delaying it slightly.

2. 块模式
The DMA controller tells the device to acquire the bus, issue a series of transfers, then release the bus. 
This form of operation is called burst mode.

这种模式更有效率，因为一次传输的数据更多
但如果传输的块很大，可能阻塞 CPU 和其他设备

****************

上面介绍的 DMA 控制器让设备控制器将数据直接传输到主存为 fly-by mode
另一种模式，即 DMA 控制器让设备控制器将数据传输给 DMA 控制器，然后再传输到要传输的目标位置，这种方式更灵活，可以直接在设备和设备直接传输数据，或者内存和内存之间传输数据

大多数 DMA 控制器使用物理地址进行传输，因此操作系统需要将虚拟地址转换为物理地址写入到 DMA 控制器的地址寄存器中

****************
The disk first reads data into its internal buffer before DMA can start. 
磁盘先将数据存到磁盘控制器的缓存中而非直接存到内存中的原因如下：
1. the disk controller can verify the checksum before starting a transfer

2. the DMA transfer to memory is not time critical
If the bus were very busy, the controller might end up storing quite a few words and having a lot of administration to do as well. 
When the block is buffered internally, the bus is not needed until the DMA begins


*************
Not all computers use DMA. The argument against it is that the main CPU is often far faster than the DMA controller and can do the job much faster (when the limiting factor is not the speed of the I/O device). 

# 中断
When an I/O device has finished the work given to it, it causes an interrupt (assuming that interrupts have been
enabled by the operating system). 
It does this by asserting a signal on a bus line that it has been assigned. 
This signal is detected by the interrupt controller chip on the parentboard, which then decides what to do.

![](img/2023-10-09-19-08-54.png)

因为可能有很多 I/O 设备发送中断信号，因此 the controller puts a number on the address lines specifying which device wants attention and asserts a signal to interrupt the CPU.

The number on the address lines is used as an **index** into a table called the **interrupt vector** to fetch a new program counter. 
This program counter points to the start of the corresponding interrupt-service procedure. 
Typically **traps** and **interrupts** use the same mechanism from this point on, often sharing the same interrupt vector. 
The location of the interrupt vector can be hardwired into the machine or it can be anywhere in memory, with a CPU register (loaded by the operating system) pointing to its origin.


