现代操作系统 第二章 进程和线程

# 进程
-  A process is just an instance of an executing program, including the current values of the program counter, registers, and variables.

- 前台进程
foreground processes, that is, processes that interact with (human) users and perform work for them. 
- 后台进程
Processes that stay in the background to handle some activity such as email, Web pages, news, printing, and so on are called daemons.

Four principal events cause processes to be created:
1. System initialization.
2. Execution of a process-creation system call by a running process.
3. A user request to create a new process.
4. Initiation of a batch job.

## Process Creation
In UNIX, there is only one system call to create a new process: fork. 

This call creates an exact clone of the calling process. 
After the fork, the two processes, the parent and the child, have the same memory image, the same environment strings, and the same open files. 

After a process is created, the parent and child have their own distinct address spaces. 

Some UNIX implementations share the **program text** between the two since that cannot be modified.

Alternatively, the child may share all of the parent’s memory, but in that case the memory is shared **copy-on-write**, which means that whenever either of the two wants to modify part of the memory, that chunk of memory is explicitly copied first to make sure the modification occurs in a private memory area. 

No writable memory is shared. 

## Process Termination
通常造成进程终止的条件有：
1. Normal exit (voluntary).
such as execute **exit** system call
2. Error exit (voluntary).
3. Fatal error (involuntary).
4. Killed by another process (involuntary).

## Process Hierarchies
In some systems, when a process creates another process, the parent process and child process continue to be associated in certain ways. 
The child process can itself create more processes, forming a process hierarchy.

## Process States
![](img/2023-10-02-11-20-36.png)


***************

> [Process state](https://en.wikipedia.org/wiki/Process_state)
> [States of a Process in Operating Systems](https://www.geeksforgeeks.org/states-of-a-process-in-operating-systems/)

> These distinct states may not be recognized as such by the operating system kernel. However, they are a useful abstraction for the understanding of processes.

### Created
- The process awaits admission to the "ready" state.
- Admission will be approved or delayed by a long-term, or admission, scheduler.

- 需要申请一个空白的 PCB，完成资源分配

### Ready
- A "ready" or "waiting" process has been loaded into main memory and is awaiting execution on a CPU. 

### Running
- A process moves into the running state when it is chosen for execution.
- There is at most one running process per CPU or core.
- A process can run in either of the two modes, namely kernel mode or user mode.

### Blocked
- A process transitions to a blocked state when it cannot carry on without an external change in state or event occurring.
- For example, a process may block on a call to an I/O device such as a printer, if the printer is not available.
- Processes also commonly block when they require user input, or require access to a critical section which must be executed [atomically](https://stackoverflow.com/questions/15054086/what-does-atomic-mean-in-programming).
- Such critical sections are protected using a synchronization object such as a semaphore or mutex.


### Terminated
- A process may be terminated, either from the "running" state by completing its execution or by explicitly being killed.
- The terminated process remains in the process table as a zombie process until its parent process calls the `wait` system call to read its exit status, at which point the process is removed from the process table, finally ending the process's lifetime.
- If the parent failes to call `wait`, this process continues to consume the process table entry (concretely the process identifier or PID), and causes a resource leak.


### Additional process states
> Two additional states are available for processes in systems that support virtual memory. 
> In both of these states, processes are "stored" on secondary memory (typically a hard disk).

- 进程被**挂起**（suspended）且**不会被调度**。
A process **stops** as a result of receiving a **SIGSTOP**, **SIGTSTP**, **SIGTTIN**, or **SIGTTOU** signal, 
and it **remains** **stopped** **until** it receives a **SIGCONT** signal, at which point it becomes running again.

- 按 `Ctrl z` 可以让进程处于 suspended 的状态，相当于发送信号 `SIGSTOP` 


#### Swapped out and waiting
- suspended and waiting
- The process is removed from main memory and placed on external storage by the scheduler.
- It may be swapped back into the waiting state.
#### Swapped out and blocked
- suspended and blocked
- The process is both blocked and swapped out
- It may be swapped back in again under the same circumstances as a swapped out and waiting process.


## Implementation of Processes
To implement the process model, the operating system maintains a table (an array of structures), called the process table, with one entry per process. (Some authors call these entries process control blocks.) 

This entry contains important information about the process’state, including its program counter, stack pointer,
memory allocation, the status of its open files, its accounting and scheduling information, and everything else about the process that must be saved when the process is switched from running to ready or blocked state so that it can be restarted later as if it had never been stopped.

![](img/2023-10-02-11-53-24.png)

# 线程
Processes are used to group resources together; threads are the entities scheduled for execution on the CPU.
进程是资源分配的基本单位
线程是 CPU 调度的基本单位

## 为什么需要线程
The main reason for having threads is that in many applications, multiple activities are going on at once. 
Some of these may block from time to time. 
By decomposing such an application into multiple sequential threads that run in quasi-parallel, the programming model becomes simpler.

A second argument for having threads is that since they are lighter weight than processes, they are easier (i.e., faster) to create and destroy than processes.

Threads yield no performance gain when all of them are CPU bound, but when there is substantial computing and also substantial I/O, having threads allows these activities to overlap, thus speeding up the application.

Threads are useful on systems with multiple CPUs, where real parallelism is possible


## 线程之间共享和独占的资源

![](img/2023-10-07-11-03-42.png)

 
Each thread has its own stack. 
Each thread’s stack contains one frame for each procedure called but not yet returned from.
This frame contains the procedure’s local variables and the return address to use when the procedure call has finished.


## 线程状态
- `thread_create`
When multithreading is present, processes usually start with a single thread present. 
This thread has the ability to create new threads by calling a library procedure such as `thread_create`.

Sometimes threads are hierarchical, with a parent-child relationship, 
but often no such relationship exists, with all threads being equal.

With or without a hierarchical relationship, the creating thread is usually returned a thread identifier that names the new thread.

- `thread_exit`
When a thread has finished its work, it can exit by calling a library procedure, say, `thread_exit`.

- thread_yield
`thread_yield` allows a thread to voluntarily give up the CPU to let another thread run.

## 多线程需要考虑的问题
1. If the parent process has multiple threads, should the child also have
them? 

If not, the process may not function properly, since all of them may be essential.

If the child process gets as many threads as the parent, what happens if a thread in the parent was blocked on a read call, say, from the keyboard

2.  What happens if one thread closes a file while another one is still read-
ing from it?

